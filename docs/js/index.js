/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./bower_components/fulltilt/dist/fulltilt.js":
/*!****************************************************!*\
  !*** ./bower_components/fulltilt/dist/fulltilt.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n *\n * FULL TILT\n * http://github.com/richtr/Full-Tilt\n *\n * A standalone DeviceOrientation + DeviceMotion JavaScript library that\n * normalises orientation sensor input, applies relevant screen orientation\n * transforms, returns Euler Angle, Quaternion and Rotation\n * Matrix representations back to web developers and provides conversion\n * between all supported orientation representation types.\n *\n * Copyright: 2014 Rich Tibbett\n * License:   MIT\n *\n */\n\n(function ( window ) {\n\n// Only initialize the FULLTILT API if it is not already attached to the DOM\nif ( window.FULLTILT !== undefined && window.FULLTILT !== null ) {\n\treturn;\n}\n\nvar M_PI   = Math.PI;\nvar M_PI_2 = M_PI / 2;\nvar M_2_PI = 2 * M_PI;\n\n// Degree to Radian conversion\nvar degToRad = M_PI / 180;\nvar radToDeg = 180 / M_PI;\n\n// Internal device orientation + motion variables\nvar sensors = {\n\t\"orientation\": {\n\t\tactive:    false,\n\t\tcallbacks: [],\n\t\tdata:      undefined\n\t},\n\t\"motion\": {\n\t\tactive:    false,\n\t\tcallbacks: [],\n\t\tdata:      undefined\n\t}\n};\nvar screenActive = false;\n\n// Internal screen orientation variables\nvar hasScreenOrientationAPI = window.screen && window.screen.orientation && window.screen.orientation.angle !== undefined && window.screen.orientation.angle !== null ? true : false;\nvar screenOrientationAngle = ( hasScreenOrientationAPI ? window.screen.orientation.angle : ( window.orientation || 0 ) ) * degToRad;\n\nvar SCREEN_ROTATION_0        = 0,\n    SCREEN_ROTATION_90       = M_PI_2,\n    SCREEN_ROTATION_180      = M_PI,\n    SCREEN_ROTATION_270      = M_2_PI / 3,\n    SCREEN_ROTATION_MINUS_90 = - M_PI_2;\n\n// Math.sign polyfill\nfunction sign(x) {\n\tx = +x; // convert to a number\n\tif (x === 0 || isNaN(x))\n\t\treturn x;\n\treturn x > 0 ? 1 : -1;\n}\n\n///// Promise-based Sensor Data checker //////\n\nfunction SensorCheck(sensorRootObj) {\n\n\tvar promise = new Promise(function(resolve, reject) {\n\n\t\tvar runCheck = function (tries) {\n\n\t\t\tsetTimeout(function() {\n\n\t\t\t\tif (sensorRootObj && sensorRootObj.data) {\n\n\t\t\t\t\tresolve();\n\n\t\t\t\t} else if (tries >= 20) {\n\n\t\t\t\t\treject();\n\n\t\t\t\t} else {\n\n\t\t\t\t\trunCheck(++tries);\n\n\t\t\t\t}\n\n\t\t\t}, 50);\n\n\t\t};\n\n\t\trunCheck(0);\n\n\t});\n\n\treturn promise;\n\n}\n\n////// Internal Event Handlers //////\n\nfunction handleScreenOrientationChange () {\n\n\tif ( hasScreenOrientationAPI ) {\n\n\t\tscreenOrientationAngle = ( window.screen.orientation.angle || 0 ) * degToRad;\n\n\t} else {\n\n\t\tscreenOrientationAngle = ( window.orientation || 0 ) * degToRad;\n\n\t}\n\n}\n\nfunction handleDeviceOrientationChange ( event ) {\n\n\tsensors.orientation.data = event;\n\n\t// Fire every callback function each time deviceorientation is updated\n\tfor ( var i in sensors.orientation.callbacks ) {\n\n\t\tsensors.orientation.callbacks[ i ].call( this );\n\n\t}\n\n}\n\nfunction handleDeviceMotionChange ( event ) {\n\n\tsensors.motion.data = event;\n\n\t// Fire every callback function each time devicemotion is updated\n\tfor ( var i in sensors.motion.callbacks ) {\n\n\t\tsensors.motion.callbacks[ i ].call( this );\n\n\t}\n\n}\n\n///// FULLTILT API Root Object /////\n\nvar FULLTILT = {};\n\nFULLTILT.version = \"0.5.3\";\n\n///// FULLTILT API Root Methods /////\n\nFULLTILT.getDeviceOrientation = function(options) {\n\n\tvar promise = new Promise(function(resolve, reject) {\n\n\t\tvar control = new FULLTILT.DeviceOrientation(options);\n\n\t\tcontrol.start();\n\n\t\tvar orientationSensorCheck = new SensorCheck(sensors.orientation);\n\n\t\torientationSensorCheck.then(function() {\n\n\t\t\tcontrol._alphaAvailable = (sensors.orientation.data.alpha && sensors.orientation.data.alpha !== null);\n\t\t\tcontrol._betaAvailable = (sensors.orientation.data.beta && sensors.orientation.data.beta !== null);\n\t\t\tcontrol._gammaAvailable = (sensors.orientation.data.gamma && sensors.orientation.data.gamma !== null);\n\n\t\t\tresolve(control);\n\n\t\t}).catch(function() {\n\n\t\t\tcontrol.stop();\n\t\t\treject('DeviceOrientation is not supported');\n\n\t\t});\n\n\t});\n\n\treturn promise;\n\n};\n\nFULLTILT.getDeviceMotion = function(options) {\n\n\tvar promise = new Promise(function(resolve, reject) {\n\n\t\tvar control = new FULLTILT.DeviceMotion(options);\n\n\t\tcontrol.start();\n\n\t\tvar motionSensorCheck = new SensorCheck(sensors.motion);\n\n\t\tmotionSensorCheck.then(function() {\n\n\t\t\tcontrol._accelerationXAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.x);\n\t\t\tcontrol._accelerationYAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.y);\n\t\t\tcontrol._accelerationZAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.z);\n\n\t\t\tcontrol._accelerationIncludingGravityXAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.x);\n\t\t\tcontrol._accelerationIncludingGravityYAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.y);\n\t\t\tcontrol._accelerationIncludingGravityZAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.z);\n\n\t\t\tcontrol._rotationRateAlphaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.alpha);\n\t\t\tcontrol._rotationRateBetaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.beta);\n\t\t\tcontrol._rotationRateGammaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.gamma);\n\n\t\t\tresolve(control);\n\n\t\t}).catch(function() {\n\n\t\t\tcontrol.stop();\n\t\t\treject('DeviceMotion is not supported');\n\n\t\t});\n\n\t});\n\n\treturn promise;\n\n};\n\n\n////// FULLTILT.Quaternion //////\n\nFULLTILT.Quaternion = function ( x, y, z, w ) {\n\n\tvar quat, outQuat;\n\n\tthis.set = function ( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = w || 1;\n\n\t};\n\n\tthis.copy = function ( quaternion ) {\n\n\t\tthis.x = quaternion.x;\n\t\tthis.y = quaternion.y;\n\t\tthis.z = quaternion.z;\n\t\tthis.w = quaternion.w;\n\n\t};\n\n\tthis.setFromEuler = (function () {\n\n\t\tvar _x, _y, _z;\n\t\tvar _x_2, _y_2, _z_2;\n\t\tvar cX, cY, cZ, sX, sY, sZ;\n\n\t\treturn function ( euler ) {\n\n\t\t\teuler = euler || {};\n\n\t\t\t_z = ( euler.alpha || 0 ) * degToRad;\n\t\t\t_x = ( euler.beta || 0 ) * degToRad;\n\t\t\t_y = ( euler.gamma || 0 ) * degToRad;\n\n\t\t\t_z_2 = _z / 2;\n\t\t\t_x_2 = _x / 2;\n\t\t\t_y_2 = _y / 2;\n\n\t\t\tcX = Math.cos( _x_2 );\n\t\t\tcY = Math.cos( _y_2 );\n\t\t\tcZ = Math.cos( _z_2 );\n\t\t\tsX = Math.sin( _x_2 );\n\t\t\tsY = Math.sin( _y_2 );\n\t\t\tsZ = Math.sin( _z_2 );\n\n\t\t\tthis.set(\n\t\t\t\tsX * cY * cZ - cX * sY * sZ, // x\n\t\t\t\tcX * sY * cZ + sX * cY * sZ, // y\n\t\t\t\tcX * cY * sZ + sX * sY * cZ, // z\n\t\t\t\tcX * cY * cZ - sX * sY * sZ  // w\n\t\t\t);\n\n\t\t\tthis.normalize();\n\n\t\t\treturn this;\n\n\t\t};\n\n\t})();\n\n\tthis.setFromRotationMatrix = (function () {\n\n\t\tvar R;\n\n\t\treturn function( matrix ) {\n\n\t\t\tR = matrix.elements;\n\n\t\t\tthis.set(\n\t\t\t\t0.5 * Math.sqrt( 1 + R[0] - R[4] - R[8] ) * sign( R[7] - R[5] ), // x\n\t\t\t\t0.5 * Math.sqrt( 1 - R[0] + R[4] - R[8] ) * sign( R[2] - R[6] ), // y\n\t\t\t\t0.5 * Math.sqrt( 1 - R[0] - R[4] + R[8] ) * sign( R[3] - R[1] ), // z\n\t\t\t\t0.5 * Math.sqrt( 1 + R[0] + R[4] + R[8] )                        // w\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t};\n\n\t})();\n\n\tthis.multiply = function ( quaternion ) {\n\n\t\toutQuat = FULLTILT.Quaternion.prototype.multiplyQuaternions( this, quaternion );\n\t\tthis.copy( outQuat );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateX = function ( angle ) {\n\n\t\toutQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );\n\t\tthis.copy( outQuat );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateY = function ( angle ) {\n\n\t\toutQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );\n\t\tthis.copy( outQuat );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateZ = function ( angle ) {\n\n\t\toutQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );\n\t\tthis.copy( outQuat );\n\n\t\treturn this;\n\n\t};\n\n\tthis.normalize = function () {\n\n\t\treturn FULLTILT.Quaternion.prototype.normalize( this );\n\n\t};\n\n\t// Initialize object values\n\tthis.set( x, y, z, w );\n\n};\n\nFULLTILT.Quaternion.prototype = {\n\n\tconstructor: FULLTILT.Quaternion,\n\n\tmultiplyQuaternions: function () {\n\n\t\tvar multipliedQuat = new FULLTILT.Quaternion();\n\n\t\treturn function ( a, b ) {\n\n\t\t\tvar qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\n\t\t\tvar qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\t\t\tmultipliedQuat.set(\n\t\t\t\tqax * qbw + qaw * qbx + qay * qbz - qaz * qby, // x\n\t\t\t\tqay * qbw + qaw * qby + qaz * qbx - qax * qbz, // y\n\t\t\t\tqaz * qbw + qaw * qbz + qax * qby - qay * qbx, // z\n\t\t\t\tqaw * qbw - qax * qbx - qay * qby - qaz * qbz  // w\n\t\t\t);\n\n\t\t\treturn multipliedQuat;\n\n\t\t};\n\n\t}(),\n\n\tnormalize: function( q ) {\n\n\t\tvar len = Math.sqrt( q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w );\n\n\t\tif ( len === 0 ) {\n\n\t\t\tq.x = 0;\n\t\t\tq.y = 0;\n\t\t\tq.z = 0;\n\t\t\tq.w = 1;\n\n\t\t} else {\n\n\t\t\tlen = 1 / len;\n\n\t\t\tq.x *= len;\n\t\t\tq.y *= len;\n\t\t\tq.z *= len;\n\t\t\tq.w *= len;\n\n\t\t}\n\n\t\treturn q;\n\n\t},\n\n\trotateByAxisAngle: function () {\n\n\t\tvar outputQuaternion = new FULLTILT.Quaternion();\n\t\tvar transformQuaternion = new FULLTILT.Quaternion();\n\n\t\tvar halfAngle, sA;\n\n\t\treturn function ( targetQuaternion, axis, angle ) {\n\n\t\t\thalfAngle = ( angle || 0 ) / 2;\n\t\t\tsA = Math.sin( halfAngle );\n\n\t\t\ttransformQuaternion.set(\n\t\t\t\t( axis[ 0 ] || 0 ) * sA, // x\n\t\t\t\t( axis[ 1 ] || 0 ) * sA, // y\n\t\t\t\t( axis[ 2 ] || 0 ) * sA, // z\n\t\t\t\tMath.cos( halfAngle )    // w\n\t\t\t);\n\n\t\t\t// Multiply quaternion by q\n\t\t\toutputQuaternion = FULLTILT.Quaternion.prototype.multiplyQuaternions( targetQuaternion, transformQuaternion );\n\n\t\t\treturn FULLTILT.Quaternion.prototype.normalize( outputQuaternion );\n\n\t\t};\n\n\t}()\n\n};\n\n////// FULLTILT.RotationMatrix //////\n\nFULLTILT.RotationMatrix = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {\n\n\tvar outMatrix;\n\n\tthis.elements = new Float32Array( 9 );\n\n\tthis.identity = function () {\n\n\t\tthis.set(\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t};\n\n\tthis.set = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {\n\n\t\tthis.elements[ 0 ] = m11 || 1;\n\t\tthis.elements[ 1 ] = m12 || 0;\n\t\tthis.elements[ 2 ] = m13 || 0;\n\t\tthis.elements[ 3 ] = m21 || 0;\n\t\tthis.elements[ 4 ] = m22 || 1;\n\t\tthis.elements[ 5 ] = m23 || 0;\n\t\tthis.elements[ 6 ] = m31 || 0;\n\t\tthis.elements[ 7 ] = m32 || 0;\n\t\tthis.elements[ 8 ] = m33 || 1;\n\n\t};\n\n\tthis.copy = function ( matrix ) {\n\n\t\tthis.elements[ 0 ] = matrix.elements[ 0 ];\n\t\tthis.elements[ 1 ] = matrix.elements[ 1 ];\n\t\tthis.elements[ 2 ] = matrix.elements[ 2 ];\n\t\tthis.elements[ 3 ] = matrix.elements[ 3 ];\n\t\tthis.elements[ 4 ] = matrix.elements[ 4 ];\n\t\tthis.elements[ 5 ] = matrix.elements[ 5 ];\n\t\tthis.elements[ 6 ] = matrix.elements[ 6 ];\n\t\tthis.elements[ 7 ] = matrix.elements[ 7 ];\n\t\tthis.elements[ 8 ] = matrix.elements[ 8 ];\n\n\t};\n\n\tthis.setFromEuler = (function() {\n\n\t\tvar _x, _y, _z;\n\t\tvar cX, cY, cZ, sX, sY, sZ;\n\n\t\treturn function ( euler ) {\n\n\t\t\teuler = euler || {};\n\n\t\t\t_z = ( euler.alpha || 0 ) * degToRad;\n\t\t\t_x = ( euler.beta || 0 ) * degToRad;\n\t\t\t_y = ( euler.gamma || 0 ) * degToRad;\n\n\t\t\tcX = Math.cos( _x );\n\t\t\tcY = Math.cos( _y );\n\t\t\tcZ = Math.cos( _z );\n\t\t\tsX = Math.sin( _x );\n\t\t\tsY = Math.sin( _y );\n\t\t\tsZ = Math.sin( _z );\n\n\t\t\t//\n\t\t\t// ZXY-ordered rotation matrix construction.\n\t\t\t//\n\n\t\t\tthis.set(\n\t\t\t\tcZ * cY - sZ * sX * sY, // 1,1\n\t\t\t\t- cX * sZ,              // 1,2\n\t\t\t\tcY * sZ * sX + cZ * sY, // 1,3\n\n\t\t\t\tcY * sZ + cZ * sX * sY, // 2,1\n\t\t\t\tcZ * cX,                // 2,2\n\t\t\t\tsZ * sY - cZ * cY * sX, // 2,3\n\n\t\t\t\t- cX * sY,              // 3,1\n\t\t\t\tsX,                     // 3,2\n\t\t\t\tcX * cY                 // 3,3\n\t\t\t);\n\n\t\t\tthis.normalize();\n\n\t\t\treturn this;\n\n\t\t};\n\n\t})();\n\n\tthis.setFromQuaternion = (function() {\n\n\t\tvar sqw, sqx, sqy, sqz;\n\n\t\treturn function( q ) {\n\n\t\t\tsqw = q.w * q.w;\n\t\t\tsqx = q.x * q.x;\n\t\t\tsqy = q.y * q.y;\n\t\t\tsqz = q.z * q.z;\n\n\t\t\tthis.set(\n\t\t\t\tsqw + sqx - sqy - sqz,       // 1,1\n\t\t\t\t2 * (q.x * q.y - q.w * q.z), // 1,2\n\t\t\t\t2 * (q.x * q.z + q.w * q.y), // 1,3\n\n\t\t\t\t2 * (q.x * q.y + q.w * q.z), // 2,1\n\t\t\t\tsqw - sqx + sqy - sqz,       // 2,2\n\t\t\t\t2 * (q.y * q.z - q.w * q.x), // 2,3\n\n\t\t\t\t2 * (q.x * q.z - q.w * q.y), // 3,1\n\t\t\t\t2 * (q.y * q.z + q.w * q.x), // 3,2\n\t\t\t\tsqw - sqx - sqy + sqz        // 3,3\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t};\n\n\t})();\n\n\tthis.multiply = function ( m ) {\n\n\t\toutMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( this, m );\n\t\tthis.copy( outMatrix );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateX = function ( angle ) {\n\n\t\toutMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );\n\t\tthis.copy( outMatrix );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateY = function ( angle ) {\n\n\t\toutMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );\n\t\tthis.copy( outMatrix );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateZ = function ( angle ) {\n\n\t\toutMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );\n\t\tthis.copy( outMatrix );\n\n\t\treturn this;\n\n\t};\n\n\tthis.normalize = function () {\n\n\t\treturn FULLTILT.RotationMatrix.prototype.normalize( this );\n\n\t};\n\n\t// Initialize object values\n\tthis.set( m11, m12, m13, m21, m22, m23, m31, m32, m33 );\n\n};\n\nFULLTILT.RotationMatrix.prototype = {\n\n\tconstructor: FULLTILT.RotationMatrix,\n\n\tmultiplyMatrices: function () {\n\n\t\tvar matrix = new FULLTILT.RotationMatrix();\n\n\t\tvar aE, bE;\n\n\t\treturn function ( a, b ) {\n\n\t\t\taE = a.elements;\n\t\t\tbE = b.elements;\n\n\t\t\tmatrix.set(\n\t\t\t\taE[0] * bE[0] + aE[1] * bE[3] + aE[2] * bE[6],\n\t\t\t\taE[0] * bE[1] + aE[1] * bE[4] + aE[2] * bE[7],\n\t\t\t\taE[0] * bE[2] + aE[1] * bE[5] + aE[2] * bE[8],\n\n\t\t\t\taE[3] * bE[0] + aE[4] * bE[3] + aE[5] * bE[6],\n\t\t\t\taE[3] * bE[1] + aE[4] * bE[4] + aE[5] * bE[7],\n\t\t\t\taE[3] * bE[2] + aE[4] * bE[5] + aE[5] * bE[8],\n\n\t\t\t\taE[6] * bE[0] + aE[7] * bE[3] + aE[8] * bE[6],\n\t\t\t\taE[6] * bE[1] + aE[7] * bE[4] + aE[8] * bE[7],\n\t\t\t\taE[6] * bE[2] + aE[7] * bE[5] + aE[8] * bE[8]\n\t\t\t);\n\n\t\t\treturn matrix;\n\n\t\t};\n\n\t}(),\n\n\tnormalize: function( matrix ) {\n\n\t\tvar R = matrix.elements;\n\n\t\t// Calculate matrix determinant\n\t\tvar determinant = R[0] * R[4] * R[8] - R[0] * R[5] * R[7] - R[1] * R[3] * R[8] + R[1] * R[5] * R[6] + R[2] * R[3] * R[7] - R[2] * R[4] * R[6];\n\n\t\t// Normalize matrix values\n\t\tR[0] /= determinant;\n\t\tR[1] /= determinant;\n\t\tR[2] /= determinant;\n\t\tR[3] /= determinant;\n\t\tR[4] /= determinant;\n\t\tR[5] /= determinant;\n\t\tR[6] /= determinant;\n\t\tR[7] /= determinant;\n\t\tR[8] /= determinant;\n\n\t\tmatrix.elements = R;\n\n\t\treturn matrix;\n\n\t},\n\n\trotateByAxisAngle: function () {\n\n\t\tvar outputMatrix = new FULLTILT.RotationMatrix();\n\t\tvar transformMatrix = new FULLTILT.RotationMatrix();\n\n\t\tvar sA, cA;\n\t\tvar validAxis = false;\n\n\t\treturn function ( targetRotationMatrix, axis, angle ) {\n\n\t\t\ttransformMatrix.identity(); // reset transform matrix\n\n\t\t\tvalidAxis = false;\n\n\t\t\tsA = Math.sin( angle );\n\t\t\tcA = Math.cos( angle );\n\n\t\t\tif ( axis[ 0 ] === 1 && axis[ 1 ] === 0 && axis[ 2 ] === 0 ) { // x\n\n\t\t\t\tvalidAxis = true;\n\n\t\t\t\ttransformMatrix.elements[4] = cA;\n\t\t\t\ttransformMatrix.elements[5] = -sA;\n\t\t\t\ttransformMatrix.elements[7] = sA;\n\t\t\t\ttransformMatrix.elements[8] = cA;\n\n\t \t\t} else if ( axis[ 1 ] === 1 && axis[ 0 ] === 0 && axis[ 2 ] === 0 ) { // y\n\n\t\t\t\tvalidAxis = true;\n\n\t\t\t\ttransformMatrix.elements[0] = cA;\n\t\t\t\ttransformMatrix.elements[2] = sA;\n\t\t\t\ttransformMatrix.elements[6] = -sA;\n\t\t\t\ttransformMatrix.elements[8] = cA;\n\n\t \t\t} else if ( axis[ 2 ] === 1 && axis[ 0 ] === 0 && axis[ 1 ] === 0 ) { // z\n\n\t\t\t\tvalidAxis = true;\n\n\t\t\t\ttransformMatrix.elements[0] = cA;\n\t\t\t\ttransformMatrix.elements[1] = -sA;\n\t\t\t\ttransformMatrix.elements[3] = sA;\n\t\t\t\ttransformMatrix.elements[4] = cA;\n\n\t \t\t}\n\n\t\t\tif ( validAxis ) {\n\n\t\t\t\toutputMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( targetRotationMatrix, transformMatrix );\n\n\t\t\t\toutputMatrix = FULLTILT.RotationMatrix.prototype.normalize( outputMatrix );\n\n\t\t\t} else {\n\n\t\t\t\toutputMatrix = targetRotationMatrix;\n\n\t\t\t}\n\n\t\t\treturn outputMatrix;\n\n\t\t};\n\n\t}()\n\n};\n\n////// FULLTILT.Euler //////\n\nFULLTILT.Euler = function ( alpha, beta, gamma ) {\n\n\tthis.set = function ( alpha, beta, gamma ) {\n\n\t\tthis.alpha = alpha || 0;\n\t\tthis.beta  = beta  || 0;\n\t\tthis.gamma = gamma || 0;\n\n\t};\n\n\tthis.copy = function ( inEuler ) {\n\n\t\tthis.alpha = inEuler.alpha;\n\t\tthis.beta  = inEuler.beta;\n\t\tthis.gamma = inEuler.gamma;\n\n\t};\n\n\tthis.setFromRotationMatrix = (function () {\n\n\t\tvar R, _alpha, _beta, _gamma;\n\n\t\treturn function ( matrix ) {\n\n\t\t\tR = matrix.elements;\n\n\t\t\tif (R[8] > 0) { // cos(beta) > 0\n\n\t\t\t\t_alpha = Math.atan2(-R[1], R[4]);\n\t\t\t\t_beta  = Math.asin(R[7]); // beta (-pi/2, pi/2)\n\t\t\t\t_gamma = Math.atan2(-R[6], R[8]); // gamma (-pi/2, pi/2)\n\n\t\t\t} else if (R[8] < 0) {  // cos(beta) < 0\n\n\t\t\t\t_alpha = Math.atan2(R[1], -R[4]);\n\t\t\t\t_beta  = -Math.asin(R[7]);\n\t\t\t\t_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)\n\t\t\t\t_gamma = Math.atan2(R[6], -R[8]); // gamma (-pi/2, pi/2)\n\n\t\t\t} else { // R[8] == 0\n\n\t\t\t\tif (R[6] > 0) {  // cos(gamma) == 0, cos(beta) > 0\n\n\t\t\t\t\t_alpha = Math.atan2(-R[1], R[4]);\n\t\t\t\t\t_beta  = Math.asin(R[7]); // beta [-pi/2, pi/2]\n\t\t\t\t\t_gamma = - M_PI_2; // gamma = -pi/2\n\n\t\t\t\t} else if (R[6] < 0) { // cos(gamma) == 0, cos(beta) < 0\n\n\t\t\t\t\t_alpha = Math.atan2(R[1], -R[4]);\n\t\t\t\t\t_beta  = -Math.asin(R[7]);\n\t\t\t\t\t_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)\n\t\t\t\t\t_gamma = - M_PI_2; // gamma = -pi/2\n\n\t\t\t\t} else { // R[6] == 0, cos(beta) == 0\n\n\t\t\t\t\t// gimbal lock discontinuity\n\t\t\t\t\t_alpha = Math.atan2(R[3], R[0]);\n\t\t\t\t\t_beta  = (R[7] > 0) ? M_PI_2 : - M_PI_2; // beta = +-pi/2\n\t\t\t\t\t_gamma = 0; // gamma = 0\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// alpha is in [-pi, pi], make sure it is in [0, 2*pi).\n\t\t\tif (_alpha < 0) {\n\t\t\t\t_alpha += M_2_PI; // alpha [0, 2*pi)\n\t\t\t}\n\n\t\t\t// Convert to degrees\n\t\t\t_alpha *= radToDeg;\n\t\t\t_beta  *= radToDeg;\n\t\t\t_gamma *= radToDeg;\n\n\t\t\t// apply derived euler angles to current object\n\t\t\tthis.set( _alpha, _beta, _gamma );\n\n\t\t};\n\n\t})();\n\n\tthis.setFromQuaternion = (function () {\n\n\t\tvar _alpha, _beta, _gamma;\n\n\t\treturn function ( q ) {\n\n\t\t\tvar sqw = q.w * q.w;\n\t\t\tvar sqx = q.x * q.x;\n\t\t\tvar sqy = q.y * q.y;\n\t\t\tvar sqz = q.z * q.z;\n\n\t\t\tvar unitLength = sqw + sqx + sqy + sqz; // Normalised == 1, otherwise correction divisor.\n\t\t\tvar wxyz = q.w * q.x + q.y * q.z;\n\t\t\tvar epsilon = 1e-6; // rounding factor\n\n\t\t\tif (wxyz > (0.5 - epsilon) * unitLength) {\n\n\t\t\t\t_alpha = 2 * Math.atan2(q.y, q.w);\n\t\t\t\t_beta = M_PI_2;\n\t\t\t\t_gamma = 0;\n\n\t\t\t} else if (wxyz < (-0.5 + epsilon) * unitLength) {\n\n\t\t\t\t_alpha = -2 * Math.atan2(q.y, q.w);\n\t\t\t\t_beta = -M_PI_2;\n\t\t\t\t_gamma = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar aX = sqw - sqx + sqy - sqz;\n\t\t\t\tvar aY = 2 * (q.w * q.z - q.x * q.y);\n\n\t\t\t\tvar gX = sqw - sqx - sqy + sqz;\n\t\t\t\tvar gY = 2 * (q.w * q.y - q.x * q.z);\n\n\t\t\t\tif (gX > 0) {\n\n\t\t\t\t\t_alpha = Math.atan2(aY, aX);\n\t\t\t\t\t_beta  = Math.asin(2 * wxyz / unitLength);\n\t\t\t\t\t_gamma = Math.atan2(gY, gX);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_alpha = Math.atan2(-aY, -aX);\n\t\t\t\t\t_beta  = -Math.asin(2 * wxyz / unitLength);\n\t\t\t\t\t_beta  += _beta < 0 ? M_PI : - M_PI;\n\t\t\t\t\t_gamma = Math.atan2(-gY, -gX);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// alpha is in [-pi, pi], make sure it is in [0, 2*pi).\n\t\t\tif (_alpha < 0) {\n\t\t\t\t_alpha += M_2_PI; // alpha [0, 2*pi)\n\t\t\t}\n\n\t\t\t// Convert to degrees\n\t\t\t_alpha *= radToDeg;\n\t\t\t_beta  *= radToDeg;\n\t\t\t_gamma *= radToDeg;\n\n\t\t\t// apply derived euler angles to current object\n\t\t\tthis.set( _alpha, _beta, _gamma );\n\n\t\t};\n\n\t})();\n\n\tthis.rotateX = function ( angle ) {\n\n\t\tFULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateY = function ( angle ) {\n\n\t\tFULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );\n\n\t\treturn this;\n\n\t};\n\n\tthis.rotateZ = function ( angle ) {\n\n\t\tFULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );\n\n\t\treturn this;\n\n\t};\n\n\t// Initialize object values\n\tthis.set( alpha, beta, gamma );\n\n};\n\nFULLTILT.Euler.prototype = {\n\n\tconstructor: FULLTILT.Euler,\n\n\trotateByAxisAngle: function () {\n\n\t\tvar _matrix = new FULLTILT.RotationMatrix();\n\t\tvar outEuler;\n\n\t\treturn function ( targetEuler, axis, angle ) {\n\n\t\t\t_matrix.setFromEuler( targetEuler );\n\n\t\t\t_matrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( _matrix, axis, angle );\n\n\t\t\ttargetEuler.setFromRotationMatrix( _matrix );\n\n\t\t\treturn targetEuler;\n\n\t\t};\n\n\t}()\n\n};\n\n///// FULLTILT.DeviceOrientation //////\n\nFULLTILT.DeviceOrientation = function (options) {\n\n\tthis.options = options || {}; // by default use UA deviceorientation 'type' (\"game\" on iOS, \"world\" on Android)\n\n\tvar tries = 0;\n\tvar maxTries = 200;\n\tvar successCount = 0;\n\tvar successThreshold = 10;\n\n\tthis.alphaOffsetScreen = 0;\n\tthis.alphaOffsetDevice = undefined;\n\n\t// Create a game-based deviceorientation object (initial alpha === 0 degrees)\n\tif (this.options.type === \"game\") {\n\n\t\tvar setGameAlphaOffset = function(evt) {\n\n\t\t\tif (evt.alpha !== null) { // do regardless of whether 'evt.absolute' is also true\n\t\t\t\tthis.alphaOffsetDevice = new FULLTILT.Euler(evt.alpha, 0, 0);\n\t\t\t\tthis.alphaOffsetDevice.rotateZ( -screenOrientationAngle );\n\n\t\t\t\t// Discard first {successThreshold} responses while a better compass lock is found by UA\n\t\t\t\tif(++successCount >= successThreshold) {\n\t\t\t\t\twindow.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(++tries >= maxTries) {\n\t\t\t\twindow.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );\n\t\t\t}\n\n\t\t}.bind(this);\n\n\t\twindow.addEventListener( 'deviceorientation', setGameAlphaOffset, false );\n\n\t// Create a compass-based deviceorientation object (initial alpha === compass degrees)\n\t} else if (this.options.type === \"world\") {\n\n\t\tvar setCompassAlphaOffset = function(evt) {\n\n\t\t\tif (evt.absolute !== true && evt.webkitCompassAccuracy !== undefined && evt.webkitCompassAccuracy !== null && +evt.webkitCompassAccuracy >= 0 && +evt.webkitCompassAccuracy < 50) {\n\t\t\t\tthis.alphaOffsetDevice = new FULLTILT.Euler(evt.webkitCompassHeading, 0, 0);\n\t\t\t\tthis.alphaOffsetDevice.rotateZ( screenOrientationAngle );\n\t\t\t\tthis.alphaOffsetScreen = screenOrientationAngle;\n\n\t\t\t\t// Discard first {successThreshold} responses while a better compass lock is found by UA\n\t\t\t\tif(++successCount >= successThreshold) {\n\t\t\t\t\twindow.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(++tries >= maxTries) {\n\t\t\t\twindow.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );\n\t\t\t}\n\n\t\t}.bind(this);\n\n\t\twindow.addEventListener( 'deviceorientation', setCompassAlphaOffset, false );\n\n\t} // else... use whatever orientation system the UA provides (\"game\" on iOS, \"world\" on Android)\n\n};\n\nFULLTILT.DeviceOrientation.prototype = {\n\n\tconstructor: FULLTILT.DeviceOrientation,\n\n\tstart: function ( callback ) {\n\n\t\tif ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {\n\n\t\t\tsensors.orientation.callbacks.push( callback );\n\n\t\t}\n\n\t\tif( !screenActive ) {\n\n\t\t\tif ( hasScreenOrientationAPI ) {\n\n\t\t\twindow.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );\n\n\t\t\t} else {\n\n\t\t\t\twindow.addEventListener( 'orientationchange', handleScreenOrientationChange, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( !sensors.orientation.active ) {\n\n\t\t\twindow.addEventListener( 'deviceorientation', handleDeviceOrientationChange, false );\n\n\t\t\tsensors.orientation.active = true;\n\n\t\t}\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( sensors.orientation.active ) {\n\n\t\t\twindow.removeEventListener( 'deviceorientation', handleDeviceOrientationChange, false );\n\n\t\t\tsensors.orientation.active = false;\n\n\t\t}\n\n\t},\n\n\tlisten: function( callback ) {\n\n\t\tthis.start( callback );\n\n\t},\n\n\tgetFixedFrameQuaternion: (function () {\n\n\t\tvar euler = new FULLTILT.Euler();\n\t\tvar matrix = new FULLTILT.RotationMatrix();\n\t\tvar quaternion = new FULLTILT.Quaternion();\n\n\t\treturn function() {\n\n\t\t\tvar orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };\n\n\t\t\tvar adjustedAlpha = orientationData.alpha;\n\n\t\t\tif (this.alphaOffsetDevice) {\n\t\t\t\tmatrix.setFromEuler( this.alphaOffsetDevice );\n\t\t\t\tmatrix.rotateZ( - this.alphaOffsetScreen );\n\t\t\t\teuler.setFromRotationMatrix( matrix );\n\n\t\t\t\tif (euler.alpha < 0) {\n\t\t\t\t\teuler.alpha += 360;\n\t\t\t\t}\n\n\t\t\t\teuler.alpha %= 360;\n\n\t\t\t\tadjustedAlpha -= euler.alpha;\n\t\t\t}\n\n\t\t\teuler.set(\n\t\t\t\tadjustedAlpha,\n\t\t\t\torientationData.beta,\n\t\t\t\torientationData.gamma\n\t\t\t);\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\treturn quaternion;\n\n\t\t};\n\n\t})(),\n\n\tgetScreenAdjustedQuaternion: (function () {\n\n\t\tvar quaternion;\n\n\t\treturn function() {\n\n\t\t\tquaternion = this.getFixedFrameQuaternion();\n\n\t\t\t// Automatically apply screen orientation transform\n\t\t\tquaternion.rotateZ( - screenOrientationAngle );\n\n\t\t\treturn quaternion;\n\n\t\t};\n\n\t})(),\n\n\tgetFixedFrameMatrix: (function () {\n\n\t\tvar euler = new FULLTILT.Euler();\n\t\tvar matrix = new FULLTILT.RotationMatrix();\n\n\t\treturn function () {\n\n\t\t\tvar orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };\n\n\t\t\tvar adjustedAlpha = orientationData.alpha;\n\n\t\t\tif (this.alphaOffsetDevice) {\n\t\t\t\tmatrix.setFromEuler( this.alphaOffsetDevice );\n\t\t\t\tmatrix.rotateZ( - this.alphaOffsetScreen );\n\t\t\t\teuler.setFromRotationMatrix( matrix );\n\n\t\t\t\tif (euler.alpha < 0) {\n\t\t\t\t\teuler.alpha += 360;\n\t\t\t\t}\n\n\t\t\t\teuler.alpha %= 360;\n\n\t\t\t\tadjustedAlpha -= euler.alpha;\n\t\t\t}\n\n\t\t\teuler.set(\n\t\t\t\tadjustedAlpha,\n\t\t\t\torientationData.beta,\n\t\t\t\torientationData.gamma\n\t\t\t);\n\n\t\t\tmatrix.setFromEuler( euler );\n\n\t\t\treturn matrix;\n\n\t\t};\n\n\t})(),\n\n\tgetScreenAdjustedMatrix: (function () {\n\n\t\tvar matrix;\n\n\t\treturn function () {\n\n\t\t\tmatrix = this.getFixedFrameMatrix();\n\n\t\t\t// Automatically apply screen orientation transform\n\t\t\tmatrix.rotateZ( - screenOrientationAngle );\n\n\t\t\treturn matrix;\n\n\t\t};\n\n\t})(),\n\n\tgetFixedFrameEuler: (function () {\n\n\t\tvar euler = new FULLTILT.Euler();\n\t\tvar matrix;\n\n\t\treturn function () {\n\n\t\t\tmatrix = this.getFixedFrameMatrix();\n\n\t\t\teuler.setFromRotationMatrix( matrix );\n\n\t\t\treturn euler;\n\n\t\t};\n\n\t})(),\n\n\tgetScreenAdjustedEuler: (function () {\n\n\t\tvar euler = new FULLTILT.Euler();\n\t\tvar matrix;\n\n\t\treturn function () {\n\n\t\t\tmatrix = this.getScreenAdjustedMatrix();\n\n\t\t\teuler.setFromRotationMatrix( matrix );\n\n\t\t\treturn euler;\n\n\t\t};\n\n\t})(),\n\n\tisAbsolute: function () {\n\n\t\tif ( sensors.orientation.data && sensors.orientation.data.absolute === true ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetLastRawEventData: function () {\n\n\t\treturn sensors.orientation.data || {};\n\n\t},\n\n\t_alphaAvailable: false,\n\t_betaAvailable: false,\n\t_gammaAvailable: false,\n\n\tisAvailable: function(_valueType){\n\n\t\tswitch(_valueType){\n\t\t\tcase this.ALPHA:\n\t\t\t\treturn this._alphaAvailable;\n\n\t\t\tcase this.BETA:\n\t\t\t\treturn this._betaAvailable;\n\n\t\t\tcase this.GAMMA:\n\t\t\t\treturn this._gammaAvailable;\n\t\t}\n\n\t},\n\n\tALPHA: 'alpha',\n\tBETA: 'beta',\n\tGAMMA: 'gamma'\n\n};\n\n\n///// FULLTILT.DeviceMotion //////\n\nFULLTILT.DeviceMotion = function (options) {\n\n\tthis.options = options || {}; // placeholder object since no options are currently supported\n\n};\n\nFULLTILT.DeviceMotion.prototype = {\n\n\tconstructor: FULLTILT.DeviceMotion,\n\n\tstart: function ( callback ) {\n\n\t\tif ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {\n\n\t\t\tsensors.motion.callbacks.push( callback );\n\n\t\t}\n\n\t\tif( !screenActive ) {\n\n\t\t\tif ( hasScreenOrientationAPI ) {\n\n\t\t\t\twindow.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );\n\n\t\t\t} else {\n\n\t\t\t\twindow.addEventListener( 'orientationchange', handleScreenOrientationChange, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( !sensors.motion.active ) {\n\n\t\t\twindow.addEventListener( 'devicemotion', handleDeviceMotionChange, false );\n\n\t\t\tsensors.motion.active = true;\n\n\t\t}\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( sensors.motion.active ) {\n\n\t\t\twindow.removeEventListener( 'devicemotion', handleDeviceMotionChange, false );\n\n\t\t\tsensors.motion.active = false;\n\n\t\t}\n\n\t},\n\n\tlisten: function( callback ) {\n\n\t\tthis.start( callback );\n\n\t},\n\n\tgetScreenAdjustedAcceleration: function () {\n\n\t\tvar accData = sensors.motion.data && sensors.motion.data.acceleration ? sensors.motion.data.acceleration : { x: 0, y: 0, z: 0 };\n\t\tvar screenAccData = {};\n\n\t\tswitch ( screenOrientationAngle ) {\n\t\t\tcase SCREEN_ROTATION_90:\n\t\t\t\tscreenAccData.x = - accData.y;\n\t\t\t\tscreenAccData.y =   accData.x;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_180:\n\t\t\t\tscreenAccData.x = - accData.x;\n\t\t\t\tscreenAccData.y = - accData.y;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_270:\n\t\t\tcase SCREEN_ROTATION_MINUS_90:\n\t\t\t\tscreenAccData.x =   accData.y;\n\t\t\t\tscreenAccData.y = - accData.x;\n\t\t\t\tbreak;\n\t\t\tdefault: // SCREEN_ROTATION_0\n\t\t\t\tscreenAccData.x =   accData.x;\n\t\t\t\tscreenAccData.y =   accData.y;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tscreenAccData.z = accData.z;\n\n\t\treturn screenAccData;\n\n\t},\n\n\tgetScreenAdjustedAccelerationIncludingGravity: function () {\n\n\t\tvar accGData = sensors.motion.data && sensors.motion.data.accelerationIncludingGravity ? sensors.motion.data.accelerationIncludingGravity : { x: 0, y: 0, z: 0 };\n\t\tvar screenAccGData = {};\n\n\t\tswitch ( screenOrientationAngle ) {\n\t\t\tcase SCREEN_ROTATION_90:\n\t\t\t\tscreenAccGData.x = - accGData.y;\n\t\t\t\tscreenAccGData.y =   accGData.x;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_180:\n\t\t\t\tscreenAccGData.x = - accGData.x;\n\t\t\t\tscreenAccGData.y = - accGData.y;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_270:\n\t\t\tcase SCREEN_ROTATION_MINUS_90:\n\t\t\t\tscreenAccGData.x =   accGData.y;\n\t\t\t\tscreenAccGData.y = - accGData.x;\n\t\t\t\tbreak;\n\t\t\tdefault: // SCREEN_ROTATION_0\n\t\t\t\tscreenAccGData.x =   accGData.x;\n\t\t\t\tscreenAccGData.y =   accGData.y;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tscreenAccGData.z = accGData.z;\n\n\t\treturn screenAccGData;\n\n\t},\n\n\tgetScreenAdjustedRotationRate: function () {\n\n\t\tvar rotRateData = sensors.motion.data && sensors.motion.data.rotationRate ? sensors.motion.data.rotationRate : { alpha: 0, beta: 0, gamma: 0 };\n\t\tvar screenRotRateData = {};\n\n\t\tswitch ( screenOrientationAngle ) {\n\t\t\tcase SCREEN_ROTATION_90:\n\t\t\t\tscreenRotRateData.beta  = - rotRateData.gamma;\n\t\t\t\tscreenRotRateData.gamma =   rotRateData.beta;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_180:\n\t\t\t\tscreenRotRateData.beta  = - rotRateData.beta;\n\t\t\t\tscreenRotRateData.gamma = - rotRateData.gamma;\n\t\t\t\tbreak;\n\t\t\tcase SCREEN_ROTATION_270:\n\t\t\tcase SCREEN_ROTATION_MINUS_90:\n\t\t\t\tscreenRotRateData.beta  =   rotRateData.gamma;\n\t\t\t\tscreenRotRateData.gamma = - rotRateData.beta;\n\t\t\t\tbreak;\n\t\t\tdefault: // SCREEN_ROTATION_0\n\t\t\t\tscreenRotRateData.beta  =   rotRateData.beta;\n\t\t\t\tscreenRotRateData.gamma =   rotRateData.gamma;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tscreenRotRateData.alpha = rotRateData.alpha;\n\n\t\treturn screenRotRateData;\n\n\t},\n\n\tgetLastRawEventData: function () {\n\n\t\treturn sensors.motion.data || {};\n\n\t},\n\n\t_accelerationXAvailable: false,\n\t_accelerationYAvailable: false,\n\t_accelerationZAvailable: false,\n\n\t_accelerationIncludingGravityXAvailable: false,\n\t_accelerationIncludingGravityYAvailable: false,\n\t_accelerationIncludingGravityZAvailable: false,\n\n\t_rotationRateAlphaAvailable: false,\n\t_rotationRateBetaAvailable: false,\n\t_rotationRateGammaAvailable: false,\n\n\tisAvailable: function(_valueType){\n\n\t\tswitch(_valueType){\n\t\t\tcase this.ACCELERATION_X:\n\t\t\t\treturn this._accelerationXAvailable;\n\n\t\t\tcase this.ACCELERATION_Y:\n\t\t\t\treturn this._accelerationYAvailable;\n\n\t\t\tcase this.ACCELERATION_Z:\n\t\t\t\treturn this._accelerationZAvailable;\n\n\t\t\tcase this.ACCELERATION_INCLUDING_GRAVITY_X:\n\t\t\t\treturn this._accelerationIncludingGravityXAvailable;\n\n\t\t\tcase this.ACCELERATION_INCLUDING_GRAVITY_Y:\n\t\t\t\treturn this._accelerationIncludingGravityYAvailable;\n\n\t\t\tcase this.ACCELERATION_INCLUDING_GRAVITY_Z:\n\t\t\t\treturn this._accelerationIncludingGravityZAvailable;\n\n\t\t\tcase this.ROTATION_RATE_ALPHA:\n\t\t\t\treturn this._rotationRateAlphaAvailable;\n\n\t\t\tcase this.ROTATION_RATE_BETA:\n\t\t\t\treturn this._rotationRateBetaAvailable;\n\n\t\t\tcase this.ROTATION_RATE_GAMMA:\n\t\t\t\treturn this._rotationRateGammaAvailable;\n\t\t}\n\t},\n\n\tACCELERATION_X: 'accelerationX',\n\tACCELERATION_Y: 'accelerationY',\n\tACCELERATION_Z: 'accelerationZ',\n\n\tACCELERATION_INCLUDING_GRAVITY_X: 'accelerationIncludingGravityX',\n\tACCELERATION_INCLUDING_GRAVITY_Y: 'accelerationIncludingGravityY',\n\tACCELERATION_INCLUDING_GRAVITY_Z: 'accelerationIncludingGravityZ',\n\n\tROTATION_RATE_ALPHA: 'rotationRateAlpha',\n\tROTATION_RATE_BETA: 'rotationRateBeta',\n\tROTATION_RATE_GAMMA: 'rotationRateGamma'\n\n};\n\n////// Attach FULLTILT to root DOM element //////\n\nwindow.FULLTILT = FULLTILT;\n\n})( window );\n\n//# sourceURL=webpack:///./bower_components/fulltilt/dist/fulltilt.js?");

/***/ }),

/***/ "./bower_components/gyronorm/dist/gyronorm.js":
/*!****************************************************!*\
  !*** ./bower_components/gyronorm/dist/gyronorm.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n* JavaScript project for accessing and normalizing the accelerometer and gyroscope data on mobile devices\n*\n* @author Doruk Eker <doruk@dorukeker.com>\n* @copyright Doruk Eker <http://dorukeker.com>\n* @version 2.0.6\n* @license MIT License | http://opensource.org/licenses/MIT\n*/\n\n(function(root, factory) {\n  var e = {\n    GyroNorm: factory(),\n  };\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return e;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function() {\n  /* Constants */\n  var GAME                            = 'game';\n  var WORLD                           = 'world';\n  var DEVICE_ORIENTATION              = 'deviceorientation';\n  var ACCELERATION                    = 'acceleration';\n  var ACCELERATION_INCLUDING_GRAVITY  = 'accelerationinludinggravity';\n  var ROTATION_RATE                   = 'rotationrate';\n\n  /*-------------------------------------------------------*/\n  /* PRIVATE VARIABLES */\n\n  var _interval           = null;       // Timer to return values\n  var _isCalibrating      = false;      // Flag if calibrating\n  var _calibrationValue   = 0;          // Alpha offset value\n  var _gravityCoefficient = 0;          // Coefficient to normalze gravity related values\n  var _isRunning          = false;      // Boolean value if GyroNorm is tracking\n  var _isReady            = false;      // Boolean value if GyroNorm is is initialized\n\n  var _do                 = null;       // Object to store the device orientation values\n  var _dm                 = null;       // Object to store the device motion values\n\n  /* OPTIONS */\n  var _frequency          = 50;         // Frequency for the return data in milliseconds\n  var _gravityNormalized  = true;       // Flag if to normalize gravity values\n  var _orientationBase    = GAME;       // Can be GyroNorm.GAME or GyroNorm.WORLD. GyroNorm.GAME returns orientation values with respect to the head direction of the device. GyroNorm.WORLD returns the orientation values with respect to the actual north direction of the world.\n  var _decimalCount       = 2;          // Number of digits after the decimals point for the return values\n  var _logger             = null;       // Function to callback on error. There is no default value. It can only be set by the user on gn.init()\n  var _screenAdjusted     = false;      // If set to true it will return screen adjusted values. (e.g. On a horizontal orientation of a mobile device, the head would be one of the sides, instead of  the actual head of the device.)\n\n  var _values = {\n    do: {\n      alpha: 0,\n      beta: 0,\n      gamma: 0,\n      absolute: false\n    },\n    dm: {\n      x: 0,\n      y: 0,\n      z: 0,\n      gx: 0,\n      gy: 0,\n      gz: 0,\n      alpha: 0,\n      beta: 0,\n      gamma: 0\n    }\n  }\n\n  /*-------------------------------------------------------*/\n  /* PUBLIC FUNCTIONS */\n\n  /*\n  *\n  * Constructor function\n  *\n  */\n\n  var GyroNorm = function(options) {}\n\n  /* Constants */\n  GyroNorm.GAME                             = GAME;\n  GyroNorm.WORLD                            = WORLD;\n  GyroNorm.DEVICE_ORIENTATION               = DEVICE_ORIENTATION;\n  GyroNorm.ACCELERATION                     = ACCELERATION;\n  GyroNorm.ACCELERATION_INCLUDING_GRAVITY   = ACCELERATION_INCLUDING_GRAVITY;\n  GyroNorm.ROTATION_RATE                    = ROTATION_RATE;\n\n  /*\n  *\n  * Initialize GyroNorm instance function\n  *\n  * @param object options - values are as follows. If set in the init function they overwrite the default option values\n  * @param int options.frequency\n  * @param boolean options.gravityNormalized\n  * @param boolean options.orientationBase\n  * @param boolean options.decimalCount\n  * @param function options.logger\n  * @param function options.screenAdjusted\n  *\n  */\n\n  GyroNorm.prototype.init = function(options) {\n    // Assign options that are passed with the constructor function\n    if (options && options.frequency) _frequency = options.frequency;\n    if (options && options.gravityNormalized) _gravityNormalized = options.gravityNormalized;\n    if (options && options.orientationBase) _orientationBase = options.orientationBase;\n    if (options && typeof options.decimalCount === 'number' && options.decimalCount >= 0) _decimalCount = parseInt(options.decimalCount);\n    if (options && options.logger) _logger = options.logger;\n    if (options && options.screenAdjusted) _screenAdjusted = options.screenAdjusted;\n\n    var deviceOrientationPromise = new FULLTILT.getDeviceOrientation({ 'type': _orientationBase }).then(function(controller) {\n      _do = controller;\n    });\n\n    var deviceMotionPromise = new FULLTILT.getDeviceMotion().then(function(controller) {\n      _dm = controller;\n      // Set gravity coefficient\n      _gravityCoefficient = (_dm.getScreenAdjustedAccelerationIncludingGravity().z > 0) ? -1 : 1;\n    });\n\n    return Promise.all([deviceOrientationPromise, deviceMotionPromise]).then(function() {\n      _isReady = true;\n    });\n  }\n\n  /*\n  *\n  * Stops all the tracking and listening on the window objects\n  *\n  */\n  GyroNorm.prototype.end = function() {\n    try {\n      _isReady = false;\n      this.stop();\n      _dm.stop();\n      _do.stop();\n    } catch(err){\n      log(err);\n    }\n  }\n\n  /*\n  *\n  * Starts tracking the values\n  *\n  * @param function callback - Callback function to read the values\n  *\n  */\n  GyroNorm.prototype.start = function(callback) {\n    if (!_isReady) {\n      log({ message: 'GyroNorm is not initialized yet. First call the \"init()\" function.', code: 1 });\n      return;\n    }\n\n    _interval = setInterval(function() {\n      callback(snapShot());\n    }, _frequency);\n    _isRunning = true;\n  }\n\n  /*\n  *\n  * Stops tracking the values\n  *\n  */\n  GyroNorm.prototype.stop = function() {\n    if (_interval) {\n      clearInterval(_interval);\n      _isRunning = false;\n    }\n  }\n\n  /*\n  *\n  * Toggles if to normalize gravity related values\n  *\n  * @param boolean flag\n  *\n  */\n  GyroNorm.prototype.normalizeGravity = function(flag) {\n    _gravityNormalized = (flag) ? true : false;\n  }\n\n\n  /*\n  *\n  * Sets the current head direction as alpha = 0\n  * Can only be used if device orientation is being tracked, values are not screen adjusted, value type is GyroNorm.EULER and orientation base is GyroNorm.GAME\n  *\n  * @return: If head direction is set successfully returns true, else false\n  *\n  */\n  GyroNorm.prototype.setHeadDirection = function() {\n    if (_screenAdjusted || _orientationBase === WORLD) {\n      return false;\n    }\n\n    _calibrationValue = _do.getFixedFrameEuler().alpha;\n    return true;\n  }\n\n  /*\n  *\n  * Sets the log function\n  *\n  */\n  GyroNorm.prototype.startLogging = function(logger) {\n    if (logger) {\n      _logger = logger;\n    }\n  }\n\n  /*\n  *\n  * Sets the log function to null which stops the logging\n  *\n  */\n  GyroNorm.prototype.stopLogging = function() {\n    _logger = null;\n  }\n\n  /*\n  *\n  * Returns if certain type of event is available on the device\n  *\n  * @param string _eventType - possible values are \"deviceorientation\" , \"devicemotion\" , \"compassneedscalibration\"\n  *\n  * @return true if event is available false if not\n  *\n  */\n  GyroNorm.prototype.isAvailable = function(_eventType) {\n\n    var doSnapShot = _do.getScreenAdjustedEuler();\n    var accSnapShot = _dm.getScreenAdjustedAcceleration();\n    var accGraSnapShot = _dm.getScreenAdjustedAccelerationIncludingGravity();\n    var rotRateSnapShot = _dm.getScreenAdjustedRotationRate();\n\n    switch (_eventType) {\n      case DEVICE_ORIENTATION:\n        return ((doSnapShot.alpha && doSnapShot.alpha !== null) && (doSnapShot.beta && doSnapShot.beta !== null) && (doSnapShot.gamma && doSnapShot.gamma !== null));\n        break;\n\n      case ACCELERATION:\n        return (accSnapShot && accSnapShot.x && accSnapShot.y && accSnapShot.z);\n        break;\n\n      case ACCELERATION_INCLUDING_GRAVITY:\n        return (accGraSnapShot && accGraSnapShot.x && accGraSnapShot.y && accGraSnapShot.z);\n        break;\n\n      case ROTATION_RATE:\n        return (rotRateSnapShot && rotRateSnapShot.alpha && rotRateSnapShot.beta && rotRateSnapShot.gamma);\n        break;\n\n      default:\n        return {\n          deviceOrientationAvailable: ((doSnapShot.alpha && doSnapShot.alpha !== null) && (doSnapShot.beta && doSnapShot.beta !== null) && (doSnapShot.gamma && doSnapShot.gamma !== null)),\n          accelerationAvailable: (accSnapShot && accSnapShot.x && accSnapShot.y && accSnapShot.z),\n          accelerationIncludingGravityAvailable: (accGraSnapShot && accGraSnapShot.x && accGraSnapShot.y && accGraSnapShot.z),\n          rotationRateAvailable: (rotRateSnapShot && rotRateSnapShot.alpha && rotRateSnapShot.beta && rotRateSnapShot.gamma)\n        }\n        break;\n    }\n  }\n\n  /*\n  *\n  * Returns boolean value if the GyroNorm is running\n  *\n  */\n  GyroNorm.prototype.isRunning = function() {\n    return _isRunning;\n  }\n\n  /*-------------------------------------------------------*/\n  /* PRIVATE FUNCTIONS */\n\n  /*\n  *\n  * Utility function to round with digits after the decimal point\n  *\n  * @param float number - the original number to round\n  *\n  */\n  function rnd(number) {\n    return Math.round(number * Math.pow(10, _decimalCount)) / Math.pow(10, _decimalCount);\n  }\n\n  /*\n  *\n  * Starts calibration\n  *\n  */\n  function calibrate() {\n    _isCalibrating = true;\n    _calibrationValues = new Array();\n  }\n\n  /*\n  *\n  * Takes a snapshot of the current deviceo orientaion and device motion values\n  *\n  */\n  function snapShot() {\n    var doSnapShot = {};\n\n    if (_screenAdjusted) {\n      doSnapShot = _do.getScreenAdjustedEuler();\n    } else {\n      doSnapShot = _do.getFixedFrameEuler();\n    }\n\n    var accSnapShot = _dm.getScreenAdjustedAcceleration();\n    var accGraSnapShot = _dm.getScreenAdjustedAccelerationIncludingGravity();\n    var rotRateSnapShot = _dm.getScreenAdjustedRotationRate();\n\n    var alphaToSend = 0;\n\n    if (_orientationBase === GAME) {\n      alphaToSend = doSnapShot.alpha - _calibrationValue;\n      alphaToSend = (alphaToSend < 0) ? (360 - Math.abs(alphaToSend)) : alphaToSend;\n    } else {\n      alphaToSend = doSnapShot.alpha;\n    }\n\n    var snapShot = {\n      do: {\n        alpha: rnd(alphaToSend),\n        beta: rnd(doSnapShot.beta),\n        gamma: rnd(doSnapShot.gamma),\n        absolute: _do.isAbsolute()\n      },\n      dm: {\n        x: rnd(accSnapShot.x),\n        y: rnd(accSnapShot.y),\n        z: rnd(accSnapShot.z),\n        gx: rnd(accGraSnapShot.x),\n        gy: rnd(accGraSnapShot.y),\n        gz: rnd(accGraSnapShot.z),\n        alpha: rnd(rotRateSnapShot.alpha),\n        beta: rnd(rotRateSnapShot.beta),\n        gamma: rnd(rotRateSnapShot.gamma)\n      }\n    };\n\n    // Normalize gravity\n    if (_gravityNormalized) {\n      snapShot.dm.gx *= _gravityCoefficient;\n      snapShot.dm.gy *= _gravityCoefficient;\n      snapShot.dm.gz *= _gravityCoefficient;\n    }\n\n    return snapShot;\n  }\n\n\n  /*\n  *\n  * Starts listening to orientation event on the window object\n  *\n  */\n  function log(err) {\n    if (_logger) {\n      if (typeof(err) == 'string') {\n        err = { message: err, code: 0 }\n      }\n      _logger(err);\n    }\n  }\n\n  return GyroNorm;\n}));\n\n\n//# sourceURL=webpack:///./bower_components/gyronorm/dist/gyronorm.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Magnifier = __webpack_require__(/*! ./views/magnifier */ \"./src/js/views/magnifier.js\");\n\nvar GoogleMap = __webpack_require__(/*! ./views/map */ \"./src/js/views/map.js\");\n\nvar Common = __webpack_require__(/*! ./views/common */ \"./src/js/views/common.js\");\n\nvar BackgroundShift = __webpack_require__(/*! ./views/BackgroundShift */ \"./src/js/views/BackgroundShift.js\");\n\nvar App = function App() {\n  _classCallCheck(this, App);\n\n  var magnifier = new Magnifier(document.querySelector('.magnifier'), document.querySelector('.main'), {\n    mouse: 2.55,\n    touch: 2.0\n  });\n  var map = new GoogleMap(document.querySelectorAll('.map_embed'), {\n    lat: 35.6684134,\n    lng: 139.7570228,\n    zoom: 14\n  }); // const shift = new BackgroundShift(\n  // \t{\n  // \t\tx: 5,\n  // \t\ty: 5\n  // \t}\n  // );\n};\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  new App();\n  Common();\n});\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ }),

/***/ "./src/js/views/BackgroundShift.js":
/*!*****************************************!*\
  !*** ./src/js/views/BackgroundShift.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function _class(translate) {\n    _classCallCheck(this, _class);\n\n    window.addEventListener('resize', this._resizeHandler.bind(this));\n    document.addEventListener('mousemove', this._mousemoveHandler.bind(this));\n    this._els = document.querySelectorAll('.content');\n    this._rx = 0;\n    this._ry = 0;\n    this._translate = translate;\n\n    this._resizeHandler();\n  }\n\n  _createClass(_class, [{\n    key: \"_mousemoveHandler\",\n    value: function _mousemoveHandler(e) {\n      var rx = e.clientX / this._width - 0.5;\n      var ry = e.clientY / this._height - 0.5;\n\n      this._setPos(rx, ry);\n    }\n  }, {\n    key: \"_setPos\",\n    value: function _setPos(rx, ry) {\n      var tx = -1 * rx * this._translate.x;\n      var ty = -1 * ry * this._translate.y;\n\n      for (var i = 0; i < this._els.length; i++) {\n        var el = this._els[i];\n        el.style.transform = 'translate(' + tx + 'px, ' + ty + 'px)';\n      }\n    }\n  }, {\n    key: \"_resizeHandler\",\n    value: function _resizeHandler() {\n      this._width = window.innerWidth;\n      this._height = window.innerHeight;\n    }\n  }]);\n\n  return _class;\n}();\n\n//# sourceURL=webpack:///./src/js/views/BackgroundShift.js?");

/***/ }),

/***/ "./src/js/views/common.js":
/*!********************************!*\
  !*** ./src/js/views/common.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n  $(function () {\n    //////////////////////\n    // BTN - go to top\n    //////////////////////\n    var $pageWrapTag = Modernizr.testProp('webkitAppearance') ? $(\"body, html\") : $(\"html\");\n    var $goto = $(\".gotop\");\n    $goto.on('click', function (e) {\n      $pageWrapTag.animate({\n        scrollTop: 0\n      }, 800);\n      e.preventDefault();\n    }); //////////////////////\n    // BTN - language toggle\n    //////////////////////\n\n    var $lang = $(\".lang\");\n    var $langBtn = $(\".lang_btn\");\n    $langBtn.on('click', function (e) {\n      $lang.toggleClass(\"is-open\");\n      e.preventDefault();\n    }); //////////////////////\n    // SLIDE - each cv's works\n    //////////////////////\n\n    $('.slide').slick({\n      slidesToShow: 1,\n      slidesToScroll: 1,\n      autoplay: true,\n      accessibility: false,\n      autoplaySpeed: 1500,\n      arrows: false,\n      fade: true,\n      speed: 100,\n      swipe: true,\n      pauseOnHover: false\n    }); //////////////////////\n    // UserAgent\n    //////////////////////\n\n    var e = navigator.userAgent;\n\n    if (e.indexOf(\"Android\") != -1) {\n      $(\"html\").addClass(\"android\");\n    }\n  });\n};\n\n//# sourceURL=webpack:///./src/js/views/common.js?");

/***/ }),

/***/ "./src/js/views/magnifier.js":
/*!***********************************!*\
  !*** ./src/js/views/magnifier.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n__webpack_require__(/*! fulltilt */ \"./bower_components/fulltilt/dist/fulltilt.js\");\n\nvar _require = __webpack_require__(/*! gyronorm */ \"./bower_components/gyronorm/dist/gyronorm.js\"),\n    GyroNorm = _require.GyroNorm;\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function _class(el, content, scale) {\n    var _this = this;\n\n    _classCallCheck(this, _class);\n\n    var lensEl = document.createElement('div');\n    lensEl.classList.add('magnifier-lens');\n    el.appendChild(lensEl);\n    var lensInnerEl = document.createElement('div');\n    lensInnerEl.classList.add('magnifier-lens_inner');\n    lensEl.appendChild(lensInnerEl);\n    var contentWrapperEl = document.createElement('div');\n    contentWrapperEl.classList.add('magnifier-content_wrapper');\n    lensInnerEl.appendChild(contentWrapperEl);\n    var contentEl = document.createElement('div');\n    contentEl.classList.add('magnifier-content');\n    contentWrapperEl.appendChild(contentEl);\n    var contentInnerEl = document.createElement('div');\n    contentInnerEl.classList.add('magnifier-content_inner');\n    contentEl.appendChild(contentInnerEl);\n    var clonedContent = content.cloneNode(true);\n    contentInnerEl.appendChild(clonedContent);\n    var gn = new GyroNorm();\n    gn.init({\n      screenAdjusted: true\n    }).then(function () {\n      gn.start(_this._gnHandler.bind(_this));\n      _this._scale = scale.touch;\n    }).catch(function (e) {\n      document.addEventListener('mousemove', _this._mousemoveHandler.bind(_this));\n      _this._scale = scale.mouse;\n    });\n    window.addEventListener('scroll', this._scrollHandler.bind(this));\n    window.addEventListener('resize', this._resizeHandler.bind(this));\n    this._el = el;\n    this._contentWrapperEl = contentWrapperEl;\n    this._contentEl = contentEl;\n    this._contentInnerEl = contentInnerEl;\n    this._rx = 0;\n    this._ry = 0;\n\n    this._resizeHandler();\n  }\n\n  _createClass(_class, [{\n    key: \"_gnHandler\",\n    value: function _gnHandler(e) {\n      var rx = (e.do.gamma + 0.0) / (180.0 * 0.5) + 0.5;\n      var ry = (e.do.beta - 45.0) / (180.0 * 0.5) + 0.5;\n\n      this._setPos(rx, ry);\n    }\n  }, {\n    key: \"_mousemoveHandler\",\n    value: function _mousemoveHandler(e) {\n      var rx = e.clientX / this._width;\n      var ry = e.clientY / this._height;\n\n      this._setPos(rx, ry);\n    }\n  }, {\n    key: \"_setPos\",\n    value: function _setPos(rx, ry) {\n      var _this2 = this;\n\n      this._rx = this._rx * 0.8 + rx * 0.2;\n      this._ry = this._ry * 0.8 + ry * 0.2;\n      requestAnimationFrame(function () {\n        var tx = (_this2._rx - 0.5) * _this2._width;\n        var ty = (_this2._ry - 0.5) * _this2._height;\n        _this2._el.style.transform = 'translate(' + tx + 'px, ' + ty + 'px)';\n        _this2._contentEl.style.transform = 'scale(' + _this2._scale + ') translate(' + -tx + 'px, ' + -ty + 'px)';\n      });\n    }\n  }, {\n    key: \"_scrollHandler\",\n    value: function _scrollHandler() {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        _this3._contentInnerEl.style.top = -window.scrollY + 'px';\n      });\n    }\n  }, {\n    key: \"_resizeHandler\",\n    value: function _resizeHandler() {\n      this._width = window.innerWidth;\n      this._height = window.innerHeight;\n      this._contentWrapperEl.style.width = this._width + 'px';\n      this._contentWrapperEl.style.height = this._height + 'px';\n    }\n  }]);\n\n  return _class;\n}();\n\n//# sourceURL=webpack:///./src/js/views/magnifier.js?");

/***/ }),

/***/ "./src/js/views/map.js":
/*!*****************************!*\
  !*** ./src/js/views/map.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function _class(els, val) {\n    _classCallCheck(this, _class);\n\n    var style = [{\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#f5f5f5\"\n      }]\n    }, {\n      \"elementType\": \"labels\",\n      \"stylers\": [{\n        \"visibility\": \"off\"\n      }]\n    }, {\n      \"elementType\": \"labels.icon\",\n      \"stylers\": [{\n        \"visibility\": \"off\"\n      }]\n    }, {\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#616161\"\n      }]\n    }, {\n      \"elementType\": \"labels.text.stroke\",\n      \"stylers\": [{\n        \"color\": \"#f5f5f5\"\n      }]\n    }, {\n      \"featureType\": \"administrative.land_parcel\",\n      \"stylers\": [{\n        \"visibility\": \"off\"\n      }]\n    }, {\n      \"featureType\": \"administrative.land_parcel\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#bdbdbd\"\n      }]\n    }, {\n      \"featureType\": \"administrative.neighborhood\",\n      \"stylers\": [{\n        \"visibility\": \"off\"\n      }]\n    }, {\n      \"featureType\": \"poi\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#eeeeee\"\n      }]\n    }, {\n      \"featureType\": \"poi\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#757575\"\n      }]\n    }, {\n      \"featureType\": \"poi.park\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#e5e5e5\"\n      }]\n    }, {\n      \"featureType\": \"poi.park\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#9e9e9e\"\n      }]\n    }, {\n      \"featureType\": \"road\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#ffffff\"\n      }]\n    }, {\n      \"featureType\": \"road.arterial\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#757575\"\n      }]\n    }, {\n      \"featureType\": \"road.highway\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#dadada\"\n      }]\n    }, {\n      \"featureType\": \"road.highway\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#616161\"\n      }]\n    }, {\n      \"featureType\": \"road.local\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#9e9e9e\"\n      }]\n    }, {\n      \"featureType\": \"transit.line\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#e5e5e5\"\n      }]\n    }, {\n      \"featureType\": \"transit.station\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#eeeeee\"\n      }]\n    }, {\n      \"featureType\": \"water\",\n      \"elementType\": \"geometry\",\n      \"stylers\": [{\n        \"color\": \"#c9c9c9\"\n      }]\n    }, {\n      \"featureType\": \"water\",\n      \"elementType\": \"labels.text.fill\",\n      \"stylers\": [{\n        \"color\": \"#9e9e9e\"\n      }]\n    }];\n    var latlng = new google.maps.LatLng(val.lat, val.lng);\n    var icon = \"//\" + window.location.host + \"/images/map-icon.svg\";\n\n    for (var i = 0; i < els.length; i++) {\n      var el = els[i];\n      var map = new google.maps.Map(el, {\n        center: latlng,\n        zoom: val.zoom,\n        mapTypeControl: false,\n        streetViewControl: false,\n        styles: style\n      });\n      var marker = new google.maps.Marker({\n        map: map,\n        position: latlng,\n        icon: icon\n      });\n    }\n  }\n\n  return _class;\n}();\n\n//# sourceURL=webpack:///./src/js/views/map.js?");

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** multi ./src/js/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /Applications/MAMP/htdocs/jagda2018/src/js/index.js */\"./src/js/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/index.js?");

/***/ })

/******/ });